# Homework Assignment 1

## Reading

- **Chapters 1, 6, and 15 of [High-Performance Scientific Computing](../assets/EijkhoutIntroToHPC2020.pdf)**:

  - Focus on understanding the key principles outlined in each chapter. Take notes on:
    - Chapter 1: Basics of single-processor computing, including von Neumann architecture and memory hierarchies.
    - Chapter 6: Techniques for programming for performance, including peak performance, bandwidth, and optimization strategies.
    - Chapter 15: Complexity analysis and its importance in scientific computing.
  - Prepare to discuss how these concepts relate to high-performance computing in class.

- **The Syllabus and Course Structure**:

  - Review the syllabus and course structure on the course website.
  - Navigate to the course GitHub Discussions board:
    - Post a question about the syllabus or upvote an existing question.
    - This will ensure everyone has clarity about course expectations and structure.

## Exercises

Complete the following exercises from of [High-Performance Scientific Computing](../assets/EijkhoutIntroToHPC2020.pdf): You will be expected to present your solutions in-class on **1/23**. For each exercise, include detailed explanations and step-by-step solutions. Code solutions should be well-commented and functional. Graphs or tables should be neatly labeled.

1. **Exercises 1.1, 1.2, and 1.3**: Address the concepts of pipelining and instruction-level parallelism. Show how pipelining improves processor performance and derive the formulas for speedup and .

2. **Exercise 1.4**: Transform the recursive loop operation into a more computationally efficient version using recursive doubling. Provide detailed calculations to analyze the efficiency improvement.

3. **Exercise 1.5**: Explain why the hierarchy of cache sizes is designed with decreasing size and increasing speed. Provide both practical and theoretical justifications.

4. **Exercise 1.11**: Explore the implications of memory bandwidth and its impact on computational throughput. Discuss the balance between bandwidth and latency in modern systems.

5. **Exercise 1.14**: Analyze an algorithm’s memory access patterns and discuss how spatial locality can improve cache efficiency. Provide code examples.

6. **Exercise 1.16**: Discuss the impact of latency hiding in GPU architectures. Compare and contrast how GPUs and CPUs handle latency.

7. **Exercise 1.17**: Analyze a simple program’s memory usage using an example provided in the textbook. Create a report showing your findings.

8. **Exercise 6.2**: Evaluate bandwidth requirements for a matrix-vector multiplication. Include a clear breakdown of calculations and discuss potential optimizations.

9. **Exercises 6.3 and 6.4**: Compare the arithmetic performance of different algorithms. Create plots to visualize performance differences and discuss the role of compiler optimizations.

10. **Exercise 6.5**: Conduct a cache performance analysis using provided code. Document the process and findings in a clear, concise manner.

## Video Lecture

- **Watch this short video on [memory hierarchies](https://www.youtube.com/watch?v=_kZY4orPQW0)**:
  - Take notes on the key concepts discussed in the video, such as levels of memory, latency, and bandwidth.
  - Be prepared to explain how memory hierarchies impact computational performance.

## Tutorial

- **The Intel VTune Tutorial**:
  - Follow the instructions at [Intel VTune tutorial](https://www.intel.com/content/www/us/en/docs/vtune-profiler/tutorial-common-bottlenecks-linux/2025-0/overview.html).
  - Complete the example profiling exercise included in the tutorial.
  - You will be using VTune in your first group project

